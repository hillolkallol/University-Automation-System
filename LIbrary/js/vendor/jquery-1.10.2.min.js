       W,H = _listWrapOn(self._content,aW,self.canv,dims=dims)
        self._H = H
        self._H0 = dims and dims[0][1] or 0
        self._wrapInfo = aW,aH
        return W, 0xffffff  # force a split

    def split(self, aW, aH):
        if getattr(self,'_wrapInfo',None)!=(aW,aH): self.wrap(aW,aH)
        S = self._content[:]
        atTop = getattr(self,'_frame',None)
        if atTop: atTop = getattr(atTop,'_atTop',None)
        C0 = self._H>aH and (not self._maxHeight or aH>self._maxHeight)
        C1 = (self._H0>aH) or C0 and atTop
        if C0 or C1:
            if C0:
                from reportlab.platypus.doctemplate import FrameBreak
                A = FrameBreak
            else:
                from reportlab.platypus.doctemplate import NullActionFlowable
                A = NullActionFlowable
            S.insert(0,A())
        return S

    def identity(self, maxLen=None):
        msg = "<%s at %s%s> containing :%s" % (self.__class__.__name__,hex(id(self)),self._frameName(),"\n".join([f.identity() for f in self._content]))
        if maxLen:
            return msg[0:maxLen]
        else:
            return msg

class Macro(Flowable):
    """This is not actually drawn (i.e. it has zero height)
    but is executed when it would fit in the frame.  Allows direct
    access to the canvas through the object 'canvas'"""
    def __init__(self, command):
        self.command = command
    def __repr__(self):
        return "Macro(%s)" % repr(self.command)
    def wrap(self, availWidth, availHeight):
        return (0,0)
    def draw(self):
        exec(self.command, globals(), {'canvas':self.canv})

def _nullCallable(*args,**kwds):
    pass

class CallerMacro(Flowable):
    '''
    like Macro, but with callable command(s)
    drawCallable(self)
    wrapCallable(self,aW,aH)
    '''
    def __init__(self, drawCallable=None, wrapCallable=None):
        self._drawCallable = drawCallable or _nullCallable
        self._wrapCallable = wrapCallable or _nullCallable
    def __repr__(self):
        return "CallerMacro(%r,%r)" % (self._drawCallable,self._wrapCallable)
    def wrap(self, aW, aH):
        self._wrapCallable(self,aW,aH)
        return (0,0)
    def draw(self):
        self._drawCallable(self)

class ParagraphAndImage(Flowable):
    '''combine a Paragraph and an Image'''
    def __init__(self,P,I,xpad=3,ypad=3,side='right'):
        self.P = P
        self.I = I
        self.xpad = xpad
        self.ypad = ypad
        self._side = side

    def getSpaceBefore(self):
        return max(self.P.getSpaceBefore(),self.I.getSpaceBefore())

    def getSpaceAfter(self):
        return max(self.P.getSpaceAfter(),self.I.getSpaceAfter())

    def wrap(self,availWidth,availHeight):
        wI, hI = self.I.wrap(availWidth,availHeight)
        self.wI = wI
        self.hI = hI
        # work out widths array for breaking
        self.width = availWidth
        P = self.P
        style = P.style
        xpad = self.xpad
        ypad = self.ypad
        leading = style.leading
        leftIndent = style.leftIndent
        later_widths = availWidth - leftIndent - style.rightIndent
        intermediate_widths = later_widths - xpad - wI
        first_line_width = intermediate_widths - style.firstLineIndent
        P.width = 0
        nIW = int((hI+ypad)/(leading*1.0))
        P.blPara = P.breakLines([first_line_width] + nIW*[intermediate_widths]+[later_widths])
        if self._side=='left':
            self._offsets = [wI+xpad]*(1+nIW)+[0]
        P.height = len(P.blPara.lines)*leading
        self.height = max(hI,P.height)
        return (self.width, self.height)

    def split(self,availWidth, availHeight):
        P, wI, hI, ypad = self.P, self.wI, self.hI, self.ypad
        if hI+ypad>availHeight or len(P.frags)<=0: return []
        S = P.split(availWidth,availHeight)
        if not S: return S
        P = self.P = S[0]
        del S[0]
        style = P.style
        P.height = len(self.P.blPara.lines)*style.leading
        self.height = max(hI,P.height)
        return [self]+S

    def draw(self):
        canv = self.canv
        if self._side=='left':
            self.I.drawOn(canv,0,self.height-self.hI)
            self.P._offsets = self._offsets
            try:
                self.P.drawOn(canv,0,0)
            finally:
                del self.P._offsets
        else:
            self.I.drawOn(canv,self.width-self.wI-self.xpad,self.height-self.hI)
            self.P.drawOn(canv,0,0)

class FailOnWrap(NullDraw):
    def wrap(self, availWidth, availHeight):
        raise ValueError("FailOnWrap flowable wrapped and failing as ordered!")

class FailOnDraw(Flowable):
    def wrap(self, availWidth, availHeight):
        return 0,0

    def draw(self):
        raise ValueError("FailOnDraw flowable drawn, and failing as ordered!")

class HRFlowable(Flowable):
    '''Like the hr tag'''
    def __init__(self,
            width="80%",
            thickness=1,
            lineCap='round',
            color=lightgrey,
            spaceBefore=1, spaceAfter=1,
            hAlign='CENTER', vAlign='BOTTOM',
            dash=None):
        Flowable.__init__(self)
        self.width = width
        self.lineWidth = thickness
        self.lineCap=lineCap
        self.spaceBefore = spaceBefore
        self.spaceAfter = spaceAfter
        self.color = color
        self.hAlign = hAlign
        self.vAlign = vAlign
        self.dash = dash

    def __repr__(self):
        return "HRFlowable(width=%s, height=%s)" % (self.width, self.height)

    def wrap(self, availWidth, availHeight):
        w = self.width
        if type(w) is type(''):
            w = w.strip()
            if w.endswith('%'): w = availWidth*float(w[:-1])*0.01
            else: w = float(w)
        w = min(w,availWidth)
        self._width = w
        return w, self.lineWidth

    def draw(self):
        canv = self.canv
        canv.saveState()
        canv.setLineWidth(self.lineWidth)
        canv.setLineCap({'butt':0,'round':1, 'square': 2}[self.lineCap.lower()])
        canv.setStrokeColor(self.color)
        if self.dash: canv.setDash(self.dash)
        canv.line(0, 0, self._width, self.height)
        canv.restoreState()

class _PTOInfo:
    def __init__(self,trailer,header):
        self.trailer = _flowableSublist(trailer)
        self.header = _flowableSublist(header)

def cdeepcopy(obj):
    if hasattr(obj,'deepcopy'):
        return obj.deepcopy()
    else:
        return deepcopy(obj)

class _Container(_ContainerSpace):  #Abstract some common container like behaviour
    def drawOn(self, canv, x, y, _sW=0, scale=1.0, content=None, aW=None):
        '''we simulate being added to a frame'''
        from reportlab.platypus.doctemplate import ActionFlowable, Indenter
        x0 = x
        y0 = y
        pS = 0
        if aW is None: aW = self.width
        aW *= scale
        if content is None:
            content = self._content
        x = self._hAlignAdjust(x,_sW*scale)
        y += self.height*scale
        yt = y
        frame = getattr(self,'_frame',None)
        for c in content:
            if not ignoreContainerActions and isinstance(c,ActionFlowable):
                c.apply(self.canv._doctemplate)
                continue
            if isinstance(c,Indenter):
                x += c.left*scale
                aW -= (c.left+c.right)*scale
                continue
            w, h = c.wrapOn(canv,aW,0xfffffff)
            if (w<_FUZZ or h<_FUZZ) and not getattr(c,'_ZEROSIZE',None): continue
            if yt!=y:
                s = c.getSpaceBefore()
                if not getattr(c,'_SPACETRANSFER',False):
                    h += max(s-pS,0)
            y -= h
            fbg = getattr(frame,'_frameBGs',None)
            s = c.getSpaceAfter()
            if getattr(c,'_SPACETRANSFER',False):
                s = pS
            pS = s
            if fbg:
                fbgl, fbgr, fbgc = fbg[-1]
                fbw = scale*(frame._width-fbgl-fbgr)
                fbh = y + h + pS
                fby = max(y0,y-pS)
                fbh = max(0,fbh-fby)
                if abs(fbw)>_FUZZ and abs(fbh)>_FUZZ:
                    canv.saveState()
                    canv.setFillColor(fbgc)
                    canv.rect(x0+scale*(fbgl-frame._leftPadding)-0.1,fby-0.1,fbw+0.2,fbh+0.2,stroke=0,fill=1)
                    canv.restoreState()
            c._frame = frame
            c.drawOn(canv,x,y,_sW=aW-w)
            if c is not content[-1] and not getattr(c,'_SPACETRANSFER',None):
                y -= pS
            del c._frame

    def copyContent(self,content=None):
        C = [].append
        for c in (content or self._content):
            C(cdeepcopy(c))
        self._content = C.__self__

class PTOContainer(_Container,Flowable):
    '''PTOContainer(contentList,trailerList,headerList)

    A container for flowables decorated with trailer & header lists.
    If the split operation would be called then the trailer and header
    lists are injected before and after the split. This allows specialist
    "please turn over" and "continued from previous" like behaviours.'''
    def __init__(self,content,trailer=None,header=None):
        I = _PTOInfo(trailer,header)
        self._content = C = []
        for _ in _flowableSublist(content):
            if isinstance(_,PTOContainer):
                C.extend(_._content)
            else:
                C.append(_)
                if not hasattr(_,'_ptoinfo'): _._ptoinfo = I

    def wrap(self,availWidth,availHeight):
        self.width, self.height = _listWrapOn(self._content,availWidth,self.canv)
        return self.width,self.height

    def split(self, availWidth, availHeight):
        from reportlab.platypus.doctemplate import Indenter
        if availHeight<0: return []
        canv = self.canv
        C = self._content
        x = i = H = pS = hx = 0
        n = len(C)
        I2W = {}
        dLeft = dRight = 0
        for x in xrange(n):
            c = C[x]
            I = c._ptoinfo
            if I not in I2W.keys():
                T = I.trailer
                Hdr = I.header
                tW, tH = _listWrapOn(T, availWidth, self.canv)
                if len(T):  #trailer may have no content
                    tSB = T[0].getSpaceBefore()
                else:
                    tSB = 0
                I2W[I] = T,tW,tH,tSB
            else:
                T,tW,tH,tSB = I2W[I]
            _, h = c.wrapOn(canv,availWidth,0xfffffff)
            if isinstance(c,Indenter):
                dw = c.left+c.right
                dLeft += c.left
                dRight += c.right
                availWidth -= dw
                pS = 0
                hx = 0
            else:
                if x:
                    hx = max(c.getSpaceBefore()-pS,0)
                    h += hx
                pS = c.getSpaceAfter()
            H += h+pS
            tHS = tH+max(tSB,pS)
            if H+tHS>=availHeight-_FUZZ: break
            i += 1

        #first retract last thing we tried
        H -= (h+pS)

        #attempt a sub split on the last one we have
        aH = (availHeight-H-tHS-hx)*0.99999
        if aH>=0.05*availHeight:
            SS = c.splitOn(canv,availWidth,aH)
        else:
            SS = []

        if abs(dLeft)+abs(dRight)>1e-8:
            R1I = [Indenter(-dLeft,-dRight)]
            R2I = [Indenter(dLeft,dRight)]
        else:
            R1I = R2I = []

        if not SS:
            j = i
            while i>1 and C[i-1].getKeepWithNext():
                i -= 1
                C[i].keepWithNext = 0

            if i==1 and C[0].getKeepWithNext():
                #robin's black sheep
                i = j
                C[0].keepWithNext = 0

        F = [UseUpSpace()]

        if len(SS)>1:
            R1 = C[:i]+SS[:1]+R1I+T+F
            R2 = Hdr+R2I+SS[1:]+C[i+1:]
        elif not i:
            return []
        else:
            R1 = C[:i]+R1I+T+F
            R2 = Hdr+R2I+C[i:]
        T =  R1 + [PTOContainer(R2,[copy(x) for x in I.trailer],[copy(x) for x in I.header])]
        return T

#utility functions used by KeepInFrame
def _hmodel(s0,s1,h0,h1):
    # calculate the parameters in the model
    # h = a/s**2 + b/s
    a11 = 1./s0**2
    a12 = 1./s0
    a21 = 1./s1**2
    a22 = 1./s1
    det = a11*a22-a12*a21
    b11 = a22/det
    b12 = -a12/det
    b21 = -a21/det
    b22 = a11/det
    a = b11*h0+b12*h1
    b = b21*h0+b22*h1
    return a,b

def _qsolve(h,ab):
    '''solve the model v = a/s**2 + b/s for an s which gives us v==h'''
    a,b = ab
    if abs(a)<=_FUZZ:
        return b/h
    t = 0.5*b/a
    from math import sqrt
    f = -h/a
    r = t*t-f
    if r<0: return None
    r = sqrt(r)
    if t>=0:
        s1 = -t - r
    else:
        s1 = -t + r
    s2 = f/s1
    return max(1./s1, 1./s2)

class KeepInFrame(_Container,Flowable):
    def __init__(self, maxWidth, maxHeight, content=[], mergeSpace=1, mode='shrink', name='',hAlign='LEFT',vAlign='BOTTOM', fakeWidth=None):
        '''mode describes the action to take when overflowing
            error       raise an error in the normal way
            continue    ignore ie just draw it and report maxWidth, maxHeight
            shrink      shrinkToFit
            truncate    fit as much as possible
            set fakeWidth to False to make _listWrapOn do the 'right' thing
        '''
        self.name = name
        self.maxWidth = maxWidth
        self.maxHeight = maxHeight
        self.mode = mode
        assert mode in ('error','overflow','shrink','truncate'), '%s invalid mode value %s' % (self.identity(),mode)
        assert maxHeight>=0,  '%s invalid maxHeight value %s' % (self.identity(),maxHeight)
        if mergeSpace is None: mergeSpace = overlapAttachedSpace
        self.mergespace = mergeSpace
        self._content = content or []
        self.vAlign = vAlign
        self.hAlign = hAlign
        self.fakeWidth = fakeWidth

    def _getAvailableWidth(self):
        return self.maxWidth - self._leftExtraIndent - self._rightExtraIndent

    def identity(self, maxLen=None):
        return "<%s at %s%s%s> size=%sx%s" % (self.__class__.__name__, hex(id(self)), self._frameName(),
                getattr(self,'name','') and (' name="%s"'% getattr(self,'name','')) or '',
                getattr(self,'maxWidth','') and (' maxWidth=%s'%fp_str(getattr(self,'maxWidth',0))) or '',
                getattr(self,'maxHeight','')and (' maxHeight=%s' % fp_str(getattr(self,'maxHeight')))or '')

    def wrap(self,availWidth,availHeight):
        from reportlab.platypus.doctemplate import LayoutError
        mode = self.mode
        maxWidth = float(min(self.maxWidth or availWidth,availWidth))
        maxHeight = float(min(self.maxHeight or availHeight,availHeight))
        fakeWidth = self.fakeWidth
        W, H = _listWrapOn(self._content,maxWidth,self.canv, fakeWidth=fakeWidth)
        if (mode=='error' and (W>maxWidth+_FUZZ or H>maxHeight+_FUZZ)):
            ident = 'content %sx%s too large for %s' % (W,H,self.identity(30))
            #leave to keep apart from the raise
            raise LayoutError(ident)
        elif W<=maxWidth+_FUZZ and H<=maxHeight+_FUZZ:
            self.width = W-_FUZZ      #we take what we get
            self.height = H-_FUZZ
        elif mode in ('overflow','truncate'):   #we lie
            self.width = min(maxWidth,W)-_FUZZ
            self.height = min(maxHeight,H)-_FUZZ
        else:
            def func(x):
                x = float(x)
                W, H = _listWrapOn(self._content,x*maxWidth,self.canv, fakeWidth=fakeWidth)
                W /= x
                H /= x
                return W, H
            W0 = W
            H0 = H
            s0 = 1
            if W>maxWidth+_FUZZ:
                #squeeze out the excess width and or Height
                s1 = W/maxWidth     #linear model
                W, H = func(s1)
                if H<=maxHeight+_FUZZ:
                    self.width = W-_FUZZ
                    self.height = H-_FUZZ
                    self._scale = s1
                    return W,H
                s0 = s1
                H0 = H
                W0 = W
            s1 = H/maxHeight
            W, H = func(s1)
            self.width = W-_FUZZ
            self.height = H-_FUZZ
            self._scale = s1
            if H<min(0.95*maxHeight,maxHeight-10) or H>=maxHeight+_FUZZ:
                #the standard case W should be OK, H is short we want
                #to find the smallest s with H<=maxHeight
                H1 = H
                for f in 0, 0.01, 0.05, 0.10, 0.15:
                    #apply the quadratic model
                    s = _qsolve(maxHeight*(1-f),_hmodel(s0,s1,H0,H1))
                    W, H = func(s)
                    if H<=maxHeight+_FUZZ and W<=maxWidth+_FUZZ:
                        self.width = W-_FUZZ
                        self.height = H-_FUZZ
                        self._scale = s
                        break

        return self.width, self.height

    def drawOn(self, canv, x, y, _sW=0):
        scale = getattr(self,'_scale',1.0)
        truncate = self.mode=='truncate'
        ss = scale!=1.0 or truncate
        if ss:
            canv.saveState()
            if truncate:
                p = canv.beginPath()
                p.rect(x, y, self.width,self.height)
                canv.clipPath(p,stroke=0)
            else:
                canv.translate(x,y)
                x=y=0
                canv.scale(1.0/scale, 1.0/scale)
        _Container.drawOn(self, canv, x, y, _sW=_sW, scale=scale)
        if ss: canv.restoreState()

class ImageAndFlowables(_Container,Flowable):
    '''combine a list of flowables and an Image'''
    def __init__(self,I,F,imageLeftPadding=0,imageRightPadding=3,imageTopPadding=0,imageBottomPadding=3,
                    imageSide='right', imageHref=None):
        self._content = _flowableSublist(F)
        self._I = I
        self._irpad = imageRightPadding
        self._ilpad = imageLeftPadding
        self._ibpad = imageBottomPadding
        self._itpad = imageTopPadding
        self._side = imageSide
        self.imageHref = imageHref

    def deepcopy(self):
        c = copy(self)  #shallow
        self._reset()
        c.copyContent() #partially deep?
        return c

    def getSpaceAfter(self):
        if hasattr(self,'_C1'):
            C = self._C1
        elif hasattr(self,'_C0'):
            C = self._C0
        else:
            C = self._content
        return _Container.getSpaceAfter(self,C)

    def getSpaceBefore(self):
        return max(self._I.getSpaceBefore(),_Container.getSpaceBefore(self))

    def _reset(self):
        for a in ('_wrapArgs','_C0','_C1'):
            try:
                delattr(self,a)
            except:
                pass

    def wrap(self,availWidth,availHeight):
        canv = self.canv
        I = self._I
        if hasattr(self,'_wrapArgs'):
            if self._wrapArgs==(availWidth,availHeight) and getattr(I,'_oldDrawSize',None) is None:
                return self.width,self.height
            self._reset()
            I._unRestrictSize()
        self._wrapArgs = availWidth, availHeight
        I.wrap(availWidth,availHeight)
        wI, hI = I._restrictSize(availWidth,availHeight)
        self._wI = wI
        self._hI = hI
        ilpad = self._ilpad
        irpad = self._irpad
        ibpad = self._ibpad
        itpad = self._itpad
        self._iW = iW = availWidth - irpad - wI - ilpad
        aH = itpad + hI + ibpad
        if iW>_FUZZ:
            W,H0,self._C0,self._C1 = self._findSplit(canv,iW,aH)
        else:
            W = availWidth
            H0 = 0
        if W>iW+_FUZZ:
            self._C0 = []
            self._C1 = self._content
        aH = self._aH = max(aH,H0)
        self.width = availWidth
        if not self._C1:
            self.height = aH
        else:
            W1,H1 = _listWrapOn(self._C1,availWidth,canv)
            self.height = aH+H1
        return self.width, self.height

    def split(self,availWidth, availHeight):
        if hasattr(self,'_wrapArgs'):
            I = self._I
            if self._wrapArgs!=(availWidth,availHeight) or getattr(I,'_oldDrawSize',None) is not None:
                self._reset()
                I._unRestrictSize()
        W,H=self.wrap(availWidth,availHeight)
        if self._aH>availHeight: return []
        C1 = self._C1
        if C1:
            S = C1[0].split(availWidth,availHeight-self._aH)
            if not S:
                _C1 = []
            else:
                _C1 = [S[0]]
                C1 = S[1:]+C1[1:]
        else:
            _C1 = []
        return [ImageAndFlowables(
                    self._I,
                    self._C0+_C1,
                    imageLeftPadding=self._ilpad,
                    imageRightPadding=self._irpad,
                    imageTopPadding=self._itpad,
                    imageBottomPadding=self._ibpad,
                    imageSide=self._side, imageHref=self.imageHref)
                    ]+C1

    def drawOn(self, canv, x, y, _sW=0):
        if self._side=='left':
            Ix = x + self._ilpad
            Fx = Ix+ self._irpad + self._wI
        else:
            Ix = x + self.width-self._wI-self._irpad
            Fx = x
        self._I.drawOn(canv,Ix,y+self.height-self._itpad-self._hI)

        if self.imageHref:
            canv.linkURL(self.imageHref, (Ix, y+self.height-self._itpad-self._hI, Ix + self._wI, y+self.height), relative=1)

        if self._C0:
            _Container.drawOn(self, canv, Fx, y, content=self._C0, aW=self._iW)
        if self._C1:
            aW, aH = self._wrapArgs
            _Container.drawOn(self, canv, x, y-self._aH,content=self._C1, aW=aW)

    def _findSplit(self,canv,availWidth,availHeight,mergeSpace=1,obj=None):
        '''return max width, required height for a list of flowables F'''
        W = 0
        H = 0
        pS = sB = 0
        atTop = 1
        F = self._content
        for i,f in enumerate(F):
            w,h = f.wrapOn(canv,availWidth,0xfffffff)
            if w<=_FUZZ or h<=_FUZZ: continue
            W = max(W,w)
            if not atTop:
                s = f.getSpaceBefore()
                if mergeSpace: s = max(s-pS,0)
                H += s
            else:
                if obj is not None: obj._spaceBefore = f.getSpaceBefore()
                atTop = 0
            if H>=availHeight or w>availWidth:
                return W, availHeight, F[:i],F[i:]
            H += h
            if H>availHeight:
                from reportlab.platypus.paragraph import Paragraph
                aH = availHeight-(H-h)
                if isinstance(f,(Paragraph,Preformatted)):
                    leading = f.style.leading
                    nH = leading*int(aH/float(leading))+_FUZZ
                    if nH<aH: nH += leading
                    availHeight += nH-aH
                    aH = nH
                S = cdeepcopy(f).splitOn(canv,availWidth,aH)
                if not S:
                    return W, availHeight, F[:i],F[i:]
                else:
                    return W,availHeight,F[:i]+S[:1],S[1:]+F[i+1:]
            pS = f.getSpaceAfter()
            H += pS
        if obj is not None: obj._spaceAfter = pS
        return W, H-pS, F, []

class AnchorFlowable(Spacer):
    '''create a bookmark in the pdf'''
    _ZEROSIZE=1
    _SPACETRANSFER = True
    def __init__(self,name):
        Spacer.__init__(self,0,0)
        self._name = name

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__,self._name)

    def wrap(self,aW,aH):
        return 0,0

    def draw(self):
        self.canv.bookmarkHorizontal(self._name,0,0)

class FrameBG(AnchorFlowable):
    """Start or stop coloring the frame background
    left & right are distances from the edge of the frame to start stop colouring.
    """
    _ZEROSIZE=1
    def __init__(self, color=None, left=0, right=0, start=True):
        Spacer.__init__(self,0,0)
        self.start = start
        if start:
            from reportlab.platypus.doctemplate import _evalMeasurement
            self.left = _evalMeasurement(left)
            self.right = _evalMeasurement(right)
            self.color = color

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__,', '.join(['%s=%r' % (i,getattr(self,i,None)) for i in 'start color left right'.split()]))

    def draw(self):
        frame = getattr(self,'_frame',None)
        if frame is None: return
        if self.start:
            w = getattr(frame,'_lineWidth',0)
            frame._frameBGs.append((self.left,self.right,self.color))
        elif frame._frameBGs:
            frame._frameBGs.pop()

class FrameSplitter(NullDraw):
    '''When encountered this flowable should either switch directly to nextTemplate
    if remaining space in the current frame is less than gap+required or it should
    temporarily modify the current template to have the frames from nextTemplate
    that are listed in nextFrames and switch to the first of those frames. 
    '''
    _ZEROSIZE=1
    def __init__(self,nextTemplate,nextFrames=[],gap=10,required=72):
        self.nextTemplate=nextTemplate
        self.nextFrames=nextFrames or []
        self.gap=gap
        self.required=required

    def wrap(self,aW,aH):
        frame = self._frame
        from reportlab.platypus.doctemplate import NextPageTemplate,CurrentFrameFlowable,LayoutError
        G=[NextPageTemplate(self.nextTemplate)]
        if aH<self.gap+self.required-_FUZZ:
            #we are going straight to the nextTemplate with no attempt to modify the frames
            G.append(PageBreak())
        else:
            #we are going to modify the incoming templates
            templates = self._doctemplateAttr('pageTemplates')
            if templates is None:
                raise LayoutError('%s called in non-doctemplate environment'%self.identity())
            T=[t for t in templates if t.id==self.nextTemplate]
            if not T:
                raise LayoutError('%s.nextTemplate=%s not found' % (self.identity(),self.nextTemplate))
            T=T[0]
            F=[f for f in T.frames if f.id in self.nextFrames]
            N=[f.id for f in F]
            N=[f for f in self.nextFrames if f not in N]
            if N:
                raise LayoutError('%s frames=%r not found in pageTemplate(%s)\n%r has frames %r' % (self.identity(),N,T.id,T,[f.id for f in T.frames]))
            T=self._doctemplateAttr('pageTemplate')
            def unwrap(canv,doc,T=T,onPage=T.onPage,oldFrames=T.frames):
                T.frames=oldFrames
                T.onPage=onPage
                onPage(canv,doc)
            T.onPage=unwrap
            h=aH-self.gap
            for i,f in enumerate(F):
                f=copy(f)
                f.height=h
                f._reset()
                F[i]=f
            T.frames=F
            G.append(CurrentFrameFlowable(F[0].id))
        frame.add_generated_content(*G)
        return 0,0


from reportlab.lib.sequencer import _type2formatter
_bulletNames = dict(
                bulletchar=u'\u2022',   #usually a small circle
                circle=u'\u25cf',   #circle as high as the font
                square=u'\u25a0',
                disc=u'\u25cf',
                diamond=u'\u25c6',
                rarrowhead=u'\u27a4',
                )

def _bulletFormat(value,type='1',format=None):
    if type=='bullet':
        s = _bulletNames.get(value,value)
    else:
        s = _type2formatter[type](int(value))

    if format:
        if isinstance(format,str):
            s = format % s
        elif isinstance(format, collections.Callable):
            s = format(s)
        else:
            raise ValueError('unexpected BulletDrawer format %r' % format)
    return s

class BulletDrawer:
    def __init__(self,
                    value='0',
                    bulletAlign='left',
                    bulletType='1',
                    bulletColor='black',
                    bulletFontName='Helvetica',
                    bulletFontSize=12,
                    bulletOffsetY=0,
                    bulletDedent=0,
                    bulletDir='ltr',
                    bulletFormat=None,
                    ):
        self.value = value
        self._bulletAlign = bulletAlign
        self._bulletType = bulletType
        self._bulletColor = bulletColor
        self._bulletFontName = bulletFontName
        self._bulletFontSize = bulletFontSize
        self._bulletOffsetY = bulletOffsetY
        self._bulletDedent = bulletDedent
        self._bulletDir = bulletDir
        self._bulletFormat = bulletFormat

    def drawOn(self,indenter,canv,x,y,_sW=0):
        value = self.value
        if not value: return
        canv.saveState()
        canv.translate(x, y)

        y = indenter.height-self._bulletFontSize+self._bulletOffsetY
        if self._bulletDir=='rtl':
            x = indenter.width - indenter._rightIndent + self._bulletDedent
        else:
            x = indenter._leftIndent - self._bulletDedent
        canv.setFont(self._bulletFontName,self._bulletFontSize)
        canv.setFillColor(self._bulletColor)
        bulletAlign = self._bulletAlign
        value = _bulletFormat(value,self._bulletType,self._bulletFormat)

        if bulletAlign=='left':
            canv.drawString(x,y,value)
        elif bulletAlign=='right':
            canv.drawRightString(x,y,value)
        elif bulletAlign in ('center','centre'):
            canv.drawCentredString(x,y,value)
        elif bulletAlign.startswith('numeric') or bulletAlign.startswith('decimal'):
            pc = bulletAlign[7:].strip() or '.'
            canv.drawAlignedString(x,y,value,pc)
        else:
            raise ValueError('Invalid bulletAlign: %r' % bulletAlign)
        canv.restoreState()

def _computeBulletWidth(b,value):
    value = _bulletFormat(value,b._bulletType,b._bulletFormat)
    return stringWidth(value,b._bulletFontName,b._bulletFontSize)

class DDIndenter(Flowable):
    _IndenterAttrs = '_flowable _leftIndent _rightIndent width height'.split()
    def __init__(self,flowable,leftIndent=0,rightIndent=0):
        self._flowable = flowable
        self._leftIndent = leftIndent
        self._rightIndent = rightIndent
        self.width = None
        self.height = None

    def split(self, aW, aH):
        S = self._flowable.split(aW-self._leftIndent-self._rightIndent, aH)
        return [
                DDIndenter(s,
                        leftIndent=self._leftIndent,
                        rightIndent=self._rightIndent,
                        ) for s in S
                ]

    def drawOn(self, canv, x, y, _sW=0):
        self._flowable.drawOn(canv,x+self._leftIndent,y,max(0,_sW-self._leftIndent-self._rightIndent))

    def wrap(self, aW, aH):
        w,h = self._flowable.wrap(aW-self._leftIndent-self._rightIndent, aH)
        self.width = w+self._leftIndent+self._rightIndent
        self.height = h
        return self.width,h

    def __getattr__(self,a):
        if a in self._IndenterAttrs:
            try:
                return self.__dict__[a]
            except KeyError:
                if a not in ('spaceBefore','spaceAfter'):
                    raise
        return getattr(self._flowable,a)

    def __setattr__(self,a,v):
        if a in self._IndenterAttrs:
            self.__dict__[a] = v
        else:
            setattr(self._flowable,a,v)

    def __delattr__(self,a):
        if a in self._IndenterAttrs:
            del self.__dict__[a]
        else:
            delattr(self._flowable,a)

    def identity(self,maxLen=None):
        return '%s containing %s' % (self.__class__.__name__,self._flowable.identity(maxLen))

class LIIndenter(DDIndenter):
    _IndenterAttrs = '_flowable _bullet _leftIndent _rightIndent width height spaceBefore spaceAfter'.split()
    def __init__(self,flowable,leftIndent=0,rightIndent=0,bullet=None, spaceBefore=None, spaceAfter=None):
        self._flowable = flowable
        self._bullet = bullet
        self._leftIndent = leftIndent
        self._rightIndent = rightIndent
        self.width = None
        self.height = None
        if spaceBefore is not None:
            self.spaceBefore = spaceBefore
        if spaceAfter is not None:
            self.spaceAfter = spaceAfter

    def split(self, aW, aH):
        S = self._flowable.split(aW-self._leftIndent-self._rightIndent, aH)
        return [
                LIIndenter(s,
                        leftIndent=self._leftIndent,
                        rightIndent=self._rightIndent,
                        bullet = (s is S[0] and self._bullet or None),
                        ) for s in S
                ]

    def drawOn(self, canv, x, y, _sW=0):
        if self._bullet:
            self._bullet.drawOn(self,canv,x,y,0)
        self._flowable.drawOn(canv,x+self._leftIndent,y,max(0,_sW-self._leftIndent-self._rightIndent))


from reportlab.lib.styles import ListStyle
class ListItem:
    def __init__(self,
                    flowables,  #the initial flowables
                    style=None,
                    #leftIndent=18,
                    #rightIndent=0,
                    #spaceBefore=None,
                    #spaceAfter=None,
                    #bulletType='1',
                    #bulletColor='black',
                    #bulletFontName='Helvetica',
                    #bulletFontSize=12,
                    #bulletOffsetY=0,
                    #bulletDedent='auto',
                    #bulletDir='ltr',
                    #bulletFormat=None,
                    **kwds
                    ):
        if not isinstance(flowables,(list,tuple)):
            flowables = (flowables,)
        self._flowables = flowables
        params = self._params = {}

        if style:
            if not isinstance(style,ListStyle):
                raise ValueError('%s style argument (%r) not a ListStyle' % (self.__class__.__name__,style))
            self._style = style

        for k in ListStyle.defaults:
            if k in kwds:
                v = kwds.get(k)
            elif style:
                v = getattr(style,k)
            else:
                continue
            params[k] = v

        for k in ('value', 'spaceBefore','spaceAfter'):
            v = kwds.get(k,getattr(style,k,None))
            if v is not None:
                params[k] = v

class _LIParams:
    def __init__(self,flowable,params,value,first):
        self.flowable = flowable
        self.params = params
        self.value = value
        self.first= first

class ListFlowable(_Container,Flowable):
    def __init__(self,
                    flowables,  #the initial flowables
                    start=1,
                    style=None,
                    #leftIndent=18,
                    #rightIndent=0,
                    #spaceBefore=None,
                    #spaceAfter=None,
                    #bulletType='1',
                    #bulletColor='black',
                    #bulletFontName='Helvetica',
                    #bulletFontSize=12,
                    #bulletOffsetY=0,
                    #bulletDedent='auto',
                    #bulletDir='ltr',
                    #bulletFormat=None,
                    **kwds
                    ):
        self._flowables = flowables

        if style:
            if not isinstance(style,ListStyle):
                raise ValueError('%s style argument not a ListStyle' % self.__class__.__name__)
            self.style = style

        for k,v in ListStyle.defaults.items():
            setattr(self,'_'+k,kwds.get(k,getattr(style,k,v)))
        if start is None:
            start = getattr(self,'_start',None)
            if start is None:
                if getattr(self,'_bulletType','1')=='bullet':
                    start = 'bulletchar'
                else:
                    start = '1'
        self._start = start

        for k in ('spaceBefore','spaceAfter'):
            v = kwds.get(k,getattr(style,k,None))
            if v is not None:
                setattr(self,k,v)

        self._content = self._getContent()
        del self._flowables
        self._dims = None

    def wrap(self,aW,aH):
        if self._dims!=aW:
            self.width, self.height = _listWrapOn(self._content,aW,self.canv)
            self._dims = aW
        return self.width,self.height

    def split(self,aW,aH):
        return self._content

    def _flowablesIter(self):
        for f in self._flowables:
            if isinstance(f,(list,tuple)):
                if f:
                    for i, z in enumerate(f):
                        yield i==0 and not isinstance(z,LIIndenter), z
            elif isinstance(f,ListItem):
                params = f._params
                if not params:
                    #meerkat simples just a list like object
                    for i, z in enumerate(f._flowables):
                        if isinstance(z,LIIndenter):
                            raise ValueError('LIIndenter not allowed in ListItem')
                        yield i==0, z
                else:
                    params = params.copy()
                    value = params.pop('value',None)
                    spaceBefore = params.pop('spaceBefore',None)
                    spaceAfter = params.pop('spaceAfter',None)
                    n = len(f._flowables) - 1
                    for i, z in enumerate(f._flowables):
                        P = params.copy()
                        if not i and spaceBefore is not None:
                            P['spaceBefore'] = spaceBefore
                        if i==n and spaceAfter is not None:
                            P['spaceAfter'] = spaceAfter
                        if i: value=None
                        yield 0, _LIParams(z,P,value,i==0)
            else:
                yield not isinstance(f,LIIndenter), f

    def _makeLIIndenter(self,flowable, bullet, params=None):
        if params:
            leftIndent = params.get('leftIndent',self._leftIndent)
            rightIndent = params.get('rightIndent',self._rightIndent)
            spaceBefore = params.get('spaceBefore',None)
            spaceAfter = params.get('spaceAfter',None)
            return LIIndenter(flowable,leftIndent,rightIndent,bullet,spaceBefore=spaceBefore,spaceAfter=spaceAfter)
        else:
            return LIIndenter(flowable,self._leftIndent,self._rightIndent,bullet)

    def _makeBullet(self,value,params=None):
        if params is None:
            def getp(a):
                return getattr(self,'_'+a)
        else:
            style = getattr(params,'style',None)
            def getp(a):
                if a in params: return params[a]
                if style and a in style.__dict__: return getattr(self,a)
                return getattr(self,'_'+a)

        return BulletDrawer(
                    value=value,
                    bulletAlign=getp('bulletAlign'),
                    bulletType=getp('bulletType'),
                    bulletColor=getp('bulletColor'),
                    bulletFontName=getp('bulletFontName'),
                    bulletFontSize=getp('bulletFontSize'),
                    bulletOffsetY=getp('bulletOffsetY'),
                    bulletDedent=getp('calcBulletDedent'),
                    bulletDir=getp('bulletDir'),
                    bulletFormat=getp('bulletFormat'),
                    )

    def _getContent(self):
        value = self._start
        bt = self._bulletType
        inc = int(bt in '1aAiI')
        if inc: value = int(value)

        bd = self._bulletDedent
        if bd=='auto':
            align = self._bulletAlign
            dir = self._bulletDir
            if dir=='ltr' and align=='left':
                bd = self._leftIndent
            elif align=='right':
                bd = self._rightIndent
            else:
                #we need to work out the maximum width of any of the labels
                tvalue = value
                maxW = 0
                for d,f in self._flowablesIter():
                    if d:
                        maxW = max(maxW,_computeBulletWidth(self,tvalue))
                        if inc: tvalue += inc
                    elif isinstance(f,LIIndenter):
                        b = f._bullet
                        if b:
                            if b.bulletType==bt:
                                maxW = max(maxW,_computeBulletWidth(b,b.value))
                                tvalue = int(b.value)
                        else:
                            maxW = max(maxW,_computeBulletWidth(self,tvalue))
                        if inc: tvalue += inc
                if dir=='ltr':
                    if align=='right':
                        bd = self._leftIndent - maxW
                    else:
                        bd = self._leftIndent - maxW*0.5
                elif align=='left':
                    bd = self._rightIndent - maxW
                else:
                    bd = self._rightIndent - maxW*0.5

        self._calcBulletDedent = bd

        S = []
        aS = S.append
        i=0
        for d,f in self._flowablesIter():
            fparams = {}
            if not i:
                i += 1
                spaceBefore = getattr(self,'spaceBefore',None)
                if spaceBefore is not None:
                    fparams['spaceBefore'] = spaceBefore
            if d:
                aS(self._makeLIIndenter(f,bullet=self._makeBullet(value),params=fparams))
                if inc: value += inc
            elif isinstance(f,LIIndenter):
                b = f._bullet
                if b:
                    if b.bulletType!=bt:
                        raise ValueError('Included LIIndenter bulletType=%s != OrderedList bulletType=%s' % (b.bulletType,bt))
                    value = int(b.value)
                else:
                    f._bullet = self._makeBullet(value,params=getattr(f,'params',None))
                if fparams:
                    f.__dict__['spaceBefore'] = max(f.__dict__.get('spaceBefore',0),spaceBefore)
                aS(f)
                if inc: value += inc
            elif isinstance(f,_LIParams):
                fparams.update(f.params)
                z = self._makeLIIndenter(f.flowable,bullet=None,params=fparams)
                if f.first:
                    if f.value is not None:
                        value = f.value
                        if inc: value = int(value)
                    z._bullet = self._makeBullet(value,f.params)
                    if inc: value += inc
                aS(z)
            else:
                aS(self._makeLIIndenter(f,bullet=None,params=fparams))

        spaceAfter = getattr(self,'spaceAfter',None)
        if spaceAfter is not None:
            f=S[-1]
            f.__dict__['spaceAfter'] = max(f.__dict__.get('spaceAfter',0),spaceAfter)
        return S

class TopPadder(Flowable):
    '''wrap a single flowable so that its first bit will be
    padded to fill out the space so that it appears at the
    bottom of its frame'''
    def __init__(self,f):
        self.__dict__['_TopPadder__f'] = f

    def wrap(self,aW,aH):
        w,h = self.__f.wrap(aW,aH)
        self.__dict__['_TopPadder__dh'] = aH-h
        return w,h

    def split(self,aW,aH):
        S = self.__f.split(aW,aH)
        if len(S)>1:
            S[0] = TopPadder(S[0])
        return S

    def drawOn(self, canvas, x, y, _sW=0):
        self.__f.drawOn(canvas,x,y-max(0,self.__dh-1e-8),_sW)

    def __setattr__(self,a,v):
        setattr(self.__f,a,v)

    def __getattr__(self,a):
        return getattr(self.__f,a)

    def __delattr__(self,a):
        delattr(self.__f,a)

class DocAssign(NullDraw):
    '''At wrap time this flowable evaluates var=expr in the doctemplate namespace'''
    _ZEROSIZE=1
    def __init__(self,var,expr,life='forever'):
        Flowable.__init__(self)
        self.args = var,expr,life

    def funcWrap(self,aW,aH):
        NS=self._doctemplateAttr('_nameSpace')
        NS.update(dict(availableWidth=aW,availableHeight=aH))
        try:
            return self.func()
        finally:
            for k in 'availableWidth','availableHeight':
                try:
                    del NS[k]
                except:
                    pass

    def func(self):
        return self._doctemplateAttr('d'+self.__class__.__name__[1:])(*self.args)

    def wrap(self,aW,aH):
        self.funcWrap(aW,aH)
        return 0,0

class DocExec(DocAssign):
    '''at wrap time exec stmt in doc._nameSpace'''
    def __init__(self,stmt,lifetime='forever'):
        Flowable.__init__(self)
        self.args=stmt,lifetime

class DocPara(DocAssign):
    '''at wrap time create a paragraph with the value of expr as text
    if format is specified it should use %(__expr__)s for string interpolation
    of the expression expr (if any). It may also use %(name)s interpolations
    for other variables in the namespace.
    suitable defaults will be used if style and klass are None
    '''
    def __init__(self,expr,format=None,style=None,klass=None,escape=True):
        Flowable.__init__(self)
        self.expr=expr
        self.format=format
        self.style=style
        self.klass=klass
        self.escape=escape

    def func(self):
        expr = self.expr
        if expr:
            if not isinstance(expr,str): expr = str(expr)
            return self._doctemplateAttr('docEval')(expr)

    def add_content(self,*args):
        self._doctemplateAttr('frame').add_generated_content(*args)

    def get_value(self,aW,aH):
        value = self.funcWrap(aW,aH)
        if self.format:
            NS=self._doctemplateAttr('_nameSpace').copy()
            NS.update(dict(availableWidth=aW,availableHeight=aH))
            NS['__expr__'] = value
            value = self.format % NS
        else:
            value = str(value)
        return value

    def wrap(self,aW,aH):
        value = self.get_value(aW,aH)
        P = self.klass
        if not P:
            from reportlab.platypus.paragraph import Paragraph as P
        style = self.style
        if not style:
            from reportlab.lib.styles import getSampleStyleSheet
            style=getSampleStyleSheet()['Code']
        if self.escape:
            from xml.sax.saxutils import escape
            value=escape(value)
        self.add_content(P(value,style=style))
        return 0,0

class DocAssert(DocPara):
    def __init__(self,cond,format=None):
        Flowable.__init__(self)
        self.expr=cond
        self.format=format

    def funcWrap(self,aW,aH):
        self._cond = DocPara.funcWrap(self,aW,aH)
        return self._cond

    def wrap(self,aW,aH):
        value = self.get_value(aW,aH)
        if not bool(self._cond):
            raise AssertionError(value)
        return 0,0

class DocIf(DocPara):
    def __init__(self,cond,thenBlock,elseBlock=[]):
        Flowable.__init__(self)
        self.expr = cond
        self.blocks = elseBlock or [],thenBlock

    def checkBlock(self,block):
        if not isinstance(block,(list,tuple)):
            block = (block,)
        return block

    def wrap(self,aW,aH):
        self.add_content(*self.checkBlock(self.blocks[int(bool(self.funcWrap(aW,aH)))]))
        return 0,0

class DocWhile(DocIf):
    def __init__(self,cond,whileBlock):
        Flowable.__init__(self)
        self.expr = cond
        self.block = self.checkBlock(whileBlock)

    def wrap(self,aW,aH):
        if bool(self.funcWrap(aW,aH)):
            self.add_content(*(list(self.block)+[self]))
        return 0,0

class SetTopFlowables(NullDraw):
    _ZEROZSIZE = 1
    def __init__(self,F,show=False):
        self._F = F
        self._show = show

    def wrap(self,aW,aH):
        doc = getattr(getattr(self,'canv',None),'_doctemplate',None)
        if doc:
            doc._topFlowables=self._F
            if self._show and self._F:
                doc.frame._generated_content = self._F
        return 0,0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #Copyright ReportLab Europe Ltd. 2000-2016
#see license.txt for license details
#history http://www.reportlab.co.uk/cgi-bin/viewcvs.cgi/public/reportlab/trunk/reportlab/platypus/frames.py

__version__='3.3.0'

__doc__="""A frame is a container for content on a page.
"""

import logging
logger = logging.getLogger('reportlab.platypus')

_geomAttr=('x1', 'y1', 'width', 'height', 'leftPadding', 'bottomPadding', 'rightPadding', 'topPadding')
from reportlab import rl_config, isPy3
_FUZZ=rl_config._FUZZ

class ShowBoundaryValue:
    def __init__(self,color=(0,0,0),width=0.1):
        self.color = color
        self.width = width

    if isPy3:
        def __bool__(self):
            return self.color is not None and self.width>=0
    else:
        def __nonzero__(self):
            return self.color is not None and self.width>=0


class Frame:
    '''
    A Frame is a piece of space in a document that is filled by the
    "flowables" in the story.  For example in a book like document most
    pages have the text paragraphs in one or two frames.  For generality
    a page might have several frames (for example for 3 column text or
    for text that wraps around a graphic).

    After creation a Frame is not usually manipulated directly by the
    applications program -- it is used internally by the platypus modules.

    Here is a diagramatid abstraction for the definitional part of a Frame::

                width                    x2,y2
        +---------------------------------+
        | l  top padding                r | h
        | e +-------------------------+ i | e
        | f |                         | g | i
        | t |                         | h | g
        |   |                         | t | h
        | p |                         |   | t
        | a |                         | p |
        | d |                         | a |
        |   |                         | d |
        |   +-------------------------+   |
        |    bottom padding               |
        +---------------------------------+
        (x1,y1) <-- lower left corner

    NOTE!! Frames are stateful objects.  No single frame should be used in
    two documents at the same time (especially in the presence of multithreading.
    '''
    def __init__(self, x1, y1, width,height, leftPadding=6, bottomPadding=6,
            rightPadding=6, topPadding=6, id=None, showBoundary=0,
            overlapAttachedSpace=None,_debug=None):
        self.id = id
        self._debug = _debug

        #these say where it goes on the page
        self.__dict__['_x1'] = x1
        self.__dict__['_y1'] = y1
        self.__dict__['_width'] = width
        self.__dict__['_height'] = height

        #these create some padding.
        self.__dict__['_leftPadding'] = leftPadding
        self.__dict__['_bottomPadding'] = bottomPadding
        self.__dict__['_rightPadding'] = rightPadding
        self.__dict__['_topPadding'] = topPadding

        # if we want a boundary to be shown
        self.showBoundary = showBoundary

        if overlapAttachedSpace is None: overlapAttachedSpace = rl_config.overlapAttachedSpace
        self._oASpace = overlapAttachedSpace
        self._geom()
        self._reset()

    def __getattr__(self,a):
        if a in _geomAttr: return self.__dict__['_'+a]
        raise AttributeError(a)

    def __setattr__(self,a,v):
        if a in _geomAttr:
            self.__dict__['_'+a] = v
            self._geom()
        else:
            self.__dict__[a] = v

    def _saveGeom(self, **kwds):
        if not self.__dict__.setdefault('_savedGeom',{}):
            for ga in _geomAttr:
                ga = '_'+ga
                self.__dict__['_savedGeom'][ga] = self.__dict__[ga]
        for k,v in kwds.items():
            setattr(self,k,v)

    def _restoreGeom(self):
        if self.__dict__.get('_savedGeom',None):
            for ga in _geomAttr:
                ga = '_'+ga
                self.__dict__[ga] = self.__dict__[ga]['_savedGeom']
                del self.__dict__['_savedGeom']
            self._geom()

    def _geom(self):
        self._x2 = self._x1 + self._width
        self._y2 = self._y1 + self._height
        #efficiency
        self._y1p = self._y1 + self._bottomPadding
        #work out the available space
        self._aW = self._x2 - self._x1 - self._leftPadding - self._rightPadding
        self._aH = self._y2 - self._y1p - self._topPadding

    def _reset(self):
        self._restoreGeom()
        #drawing starts at top left
        self._x = self._x1 + self._leftPadding
        self._y = self._y2 - self._topPadding
        self._atTop = 1
        self._prevASpace = 0

        # these two should NOT be set on a frame.
        # they are used when Indenter flowables want
        # to adjust edges e.g. to do nested lists
        self._leftExtraIndent = 0.0
        self._rightExtraIndent = 0.0

    def _getAvailableWidth(self):
        return self._aW - self._leftExtraIndent - self._rightExtraIndent

    def _add(self, flowable, canv, trySplit=0):
        """ Draws the flowable at the current position.
        Returns 1 if successful, 0 if it would not fit.
        Raises a LayoutError if the object is too wide,
        or if it is too high for a totally empty frame,
        to avoid infinite loops"""
        flowable._frame = self
        flowable.canv = canv #so they can use stringWidth etc
        try:
            if getattr(flowable,'frameAction',None):
                flowable.frameAction(self)
                return 1

            y = self._y
            p = self._y1p
            s = 0
            aW = self._getAvailableWidth()
            zeroSize = getattr(flowable,'_ZEROSIZE',False)
            if not self._atTop:
                s =flowable.getSpaceBefore()
                if self._oASpace:
                    if getattr(flowable,'_SPACETRANSFER',False) or zeroSize:
                        s = self._prevASpace
                    s = max(s-self._prevASpace,0)
            h = y - p - s
            if h>0 or zeroSize:
                w, h = flowable.wrap(aW, h)
            else:
                return 0

            h += s
            y -= h

            if y < p-_FUZZ:
                if not rl_config.allowTableBoundsErrors and ((h>self._aH or w>aW) and not trySplit):
                    from reportlab.platypus.doctemplate import LayoutError
                    raise LayoutError("Flowable %s (%sx%s points) too large for frame (%sx%s points)." % (
                        flowable.__class__, w,h, aW,self._aH))
                return 0
            else:
                #now we can draw it, and update the current point.
                s = flowable.getSpaceAfter()
                fbg = getattr(self,'_frameBGs',None)
                if fbg:
                    fbgl, fbgr, fbgc = fbg[-1]
                    fbw = self._width-fbgl-fbgr
                    fbh = y + h + s
                    fby = max(p,y-s)
                    fbh = max(0,fbh-fby)
                    if abs(fbw)>_FUZZ and abs(fbh)>_FUZZ:
                        canv.saveState()
                        canv.setFillColor(fbgc)
                        canv.rect(self._x1+fbgl,fby,fbw,fbh,stroke=0,fill=1)
                        canv.restoreState()

                flowable.drawOn(canv, self._x + self._leftExtraIndent, y, _sW=aW-w)
                flowable.canv=canv
                if self._debug: logger.debug('drew %s' % flowable.identity())
                y -= s
                if self._oASpace:
                    if getattr(flowable,'_SPACETRANSFER',False):
                        s = self._prevASpace
                    self._prevASpace = s
                if y!=self._y: self._atTop = 0
                self._y = y
                return 1
        finally:
            #sometimes canv/_frame aren't still on the flowable
            for a in ('canv', '_frame'):
                if hasattr(flowable,a):
                    delattr(flowable,a)

    add = _add

    def split(self,flowable,canv):
        '''Ask the flowable to split using up the available space.'''
        y = self._y
        p = self._y1p
        s = 0
        if not self._atTop:
            s = flowable.getSpaceBefore()
            if self._oASpace:
                s = max(s-self._prevASpace,0)
        flowable._frame = self                  #some flowables might need these
        flowable.canv = canv        
        try:
            r = flowable.split(self._aW, y-p-s)
        finally:
            #sometimes canv/_frame aren't still on the flowable
            for a in ('canv', '_frame'):
                if hasattr(flowable,a):
                    delattr(flowable,a)
        return r


    def drawBoundary(self,canv):
        "draw the frame boundary as a rectangle (primarily for debugging)."
        from reportlab.lib.colors import Color, toColor
        sb = self.showBoundary
        ss = isinstance(sb,(str,tuple,list)) or isinstance(sb,Color)
        w = -1
        if ss:
            c = toColor(sb,self)
            ss = c is not self
        elif isinstance(sb,ShowBoundaryValue) and sb:
            c = toColor(sb.color,self)
            w = sb.width
            ss = c is not self
        if ss:
            canv.saveState()
            canv.setStrokeColor(c)
            if w>=0:
                canv.setLineWidth(w)
        canv.rect(
                self._x1,
                self._y1,
                self._x2 - self._x1,
                self._y2 - self._y1
                )
        if ss: canv.restoreState()

    def addFromList(self, drawlist, canv):
        """Consumes objects from the front of the list until the
        frame is full.  If it cannot fit one object, raises
        an exception."""

        if self._debug: logger.debug("enter Frame.addFromlist() for frame %s" % self.id)
        if self.showBoundary:
            self.drawBoundary(canv)

        while len(drawlist) > 0:
            head = drawlist[0]
            if self.add(head,canv,trySplit=0):
                del drawlist[0]
            else:
                #leave it in the list for later
                break

    def add_generated_content(self,*C):
        self.__dict__.setdefault('_generated_content',[]).extend(C)

    def _aSpaceString(self):
        return '(%s x %s%s)' % (self._getAvailableWidth(),self._aH,self._atTop and '*' or '')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """new experimental paragraph implementation

Intended to allow support for paragraphs in paragraphs, hotlinks,
embedded flowables, and underlining.  The main entry point is the
function

def Paragraph(text, style, bulletText=None, frags=None)

Which is intended to be plug compatible with the "usual" platypus
paragraph except that it supports more functionality.

In this implementation you may embed paragraphs inside paragraphs
to create hierarchically organized documents.

This implementation adds the following paragraph-like tags (which
support the same attributes as paragraphs, for font specification, etc).

- Unnumberred lists (ala html)::

    <ul>
        <li>first one</li>
        <li>second one</li>
    </ul>


Also <ul type="disc"> (default) or <ul type="circle">, <ul type="square">.

- Numberred lists (ala html)::

    <ol>
        <li>first one</li>
        <li>second one</li>
    </ol>

Also <ul type="1"> (default) or <ul type="a">, <ul type="A">.

- Display lists (ala HTML):

For example

<dl bulletFontName="Helvetica-BoldOblique" spaceBefore="10" spaceAfter="10">
<dt>frogs</dt> <dd>Little green slimy things. Delicious with <b>garlic</b></dd>
<dt>kittens</dt> <dd>cute, furry, not edible</dd>
<dt>bunnies</dt> <dd>cute, furry,. Delicious with <b>garlic</b></dd>
</dl>

ALSO the following additional internal paragraph markup tags are supported

<u>underlined text</u>

<a href="http://www.reportlab.com">hyperlinked text</a>
<a href="http://www.reportlab.com" color="blue">hyperlinked text</a>

<link destination="end" >Go to the end (go to document internal destination)</link>
<link destination="start" color="cyan">Go to the beginning</link>

<setLink destination="start" color="magenta">This is the document start
  (define document destination inside paragraph, color is optional)</setLink>

"""
from reportlab.pdfbase.pdfmetrics import stringWidth
from reportlab.lib.rl_accel import fp_str
from reportlab.platypus.flowables import Flowable
from reportlab.lib import colors
from reportlab.lib.styles import _baseFontName

# SET THIS TO CAUSE A VIEWING BUG WITH ACROREAD 3 (for at least one input)
# CAUSEERROR = 0

debug = 0

DUMPPROGRAM = 0

TOOSMALLSPACE = 1e-5

from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT, TA_JUSTIFY

# indent changes effect the next line
# align changes effect the current line

# need to fix spacing questions... if ends with space then space may be inserted

# NEGATIVE SPACE SHOULD NEVER BE EXPANDED (IN JUSTIFICATION, EG)

class paragraphEngine:
    # text origin of 0,0 is upper left corner
    def __init__(self, program = None):
        from reportlab.lib.colors import black
        if program is None:
            program = []
        self.lineOpHandlers = [] # for handling underlining and hyperlinking, etc
        self.program = program
        self.indent = self.rightIndent = 0.0
        self.baseindent = 0.0 # adjust this to add more indentation for bullets, eg
        self.fontName = "Helvetica"
        self.fontSize = 10
        self.leading = 12
        self.fontColor = black
        self.x = self.y = self.rise = 0.0
        from reportlab.lib.enums import TA_LEFT
        self.alignment = TA_LEFT
        self.textStateStack = []

    TEXT_STATE_VARIABLES = ("indent", "rightIndent", "fontName", "fontSize",
                            "leading", "fontColor", "lineOpHandlers", "rise",
                            "alignment")
                            #"textStateStack")

    def pushTextState(self):
        state = []
        for var in self.TEXT_STATE_VARIABLES:
            val = getattr(self, var)
            state.append(val)
        #self.textStateStack.append(state)
        self.textStateStack = self.textStateStack+[state] # fresh copy
        #print "push", self.textStateStack
        #print "push", len(self.textStateStack), state
        return state

    def popTextState(self):
        state = self.textStateStack[-1]
        self.textStateStack = self.textStateStack[:-1]
        #print "pop", self.textStateStack
        state = state[:] # copy for destruction
        #print "pop", len(self.textStateStack), state
        #print "handlers before", self.lineOpHandlers
        for var in self.TEXT_STATE_VARIABLES:
            val = state[0]
            del state[0]
            setattr(self, var, val)

    def format(self, maxwidth, maxheight, program, leading=0):
        "return program with line operations added if at least one line fits"
        # note: a generated formatted segment should not be formatted again
        startstate = self.__dict__.copy()
        #remainder = self.cleanProgram(program)
        remainder = program[:]
        #program1 = remainder[:] # debug only
        lineprogram = []
        #if maxheight<TOOSMALLSPACE:
        #    raise ValueError, "attempt to format inside too small a height! "+repr(maxheight)
        heightremaining = maxheight
        if leading: self.leading = leading
        room = 1
        cursorcount = 0 # debug
        while remainder and room: #heightremaining>=self.leading and remainder:
            #print "getting line with statestack", len(self.textStateStack)
            #heightremaining = heightremaining - self.leading
            indent = self.indent
            rightIndent = self.rightIndent
            linewidth = maxwidth - indent - rightIndent
            beforelinestate = self.__dict__.copy()
            if linewidth<TOOSMALLSPACE:
                raise ValueError("indents %s %s too wide for space %s" % (self.indent, self.rightIndent, \
                                                                           maxwidth))
            try:
                (lineIsFull, line, cursor, currentLength, \
                 usedIndent, maxLength, justStrings) = self.fitLine(remainder, maxwidth)
            except:
##                print "failed to fit line near", cursorcount # debug
##                for i in program1[max(0,cursorcount-10): cursorcount]:
##                    print
##                    print i,
##                print "***" *8
##                for i in program1[cursorcount:cursorcount+20]:
##                    print i
                raise
            cursorcount = cursorcount+cursor # debug
            leading = self.leading
            if heightremaining>leading:
                heightremaining = heightremaining-leading
            else:
                room = 0
                #self.resetState(beforelinestate)
                self.__dict__.update(beforelinestate)
                break # no room for this line
##            if debug:
##                print "line", line
##                if lineIsFull: print "is full"
##                else: print "is partially full"
##                print "consumes", cursor, "elements"
##                print "covers", currentLength, "of", maxwidth
            alignment = self.alignment # last declared alignment for this line used
            # recompute linewidth using the used indent
            #linewidth = maxwidth - usedIndent - rightIndent
            remainder = remainder[cursor:]
            if not remainder:
                # trim off the extra end of line
                del line[-1]
            # do justification if any
            #line = self.shrinkWrap(line
            if alignment==TA_LEFT:
                #if debug:
                #    print "ALIGN LEFT"
                if justStrings:
                    line = stringLine(line, currentLength)
                else:
                    line = self.shrinkWrap(line)
                pass
            elif alignment==TA_CENTER:
                #if debug:
                #    print "ALIGN CENTER"
                if justStrings:
                    line = stringLine(line, currentLength)
                else:
                    line = self.shrinkWrap(line)
                line = self.centerAlign(line, currentLength, maxLength)
            elif alignment==TA_RIGHT:
                #if debug:
                #    print "ALIGN RIGHT"
                if justStrings:
                    line = stringLine(line, currentLength)
                else:
                    line = self.shrinkWrap(line)
                line = self.rightAlign(line, currentLength, maxLength)
            elif alignment==TA_JUSTIFY:
                #if debug:
                #    print "JUSTIFY"
                if remainder and lineIsFull:
                    if justStrings:
                        line = simpleJustifyAlign(line, currentLength, maxLength)
                    else:
                        line = self.justifyAlign(line, currentLength, maxLength)
                else:
                    if justStrings:
                        line = stringLine(line, currentLength)
                    else:
                        line = self.shrinkWrap(line)
                    if debug:
                        print("no justify because line is not full or end of para")
            else:
                raise ValueError("bad alignment "+repr(alignment))
            if not justStrings:
                line = self.cleanProgram(line)
            lineprogram.extend(line)
        laststate = self.__dict__.copy()
        #self.resetState(startstate)
        self.__dict__.update(startstate)
        heightused = maxheight - heightremaining
        return (lineprogram, remainder, laststate, heightused)

    def getState(self):
        # inlined
        return self.__dict__.copy()

    def resetState(self, state):
        # primarily inlined
        self.__dict__.update(state)

##    def sizeOfWord(self, word):
##        inlineThisFunctionForEfficiency
##        return float(stringWidth(word, self.fontName, self.fontSize))

    def fitLine(self, program, totalLength):
        "fit words (and other things) onto a line"
        # assuming word lengths and spaces have not been yet added
        # fit words onto a line up to maxlength, adding spaces and respecting extra space
        from reportlab.pdfbase.pdfmetrics import stringWidth
        usedIndent = self.indent
        maxLength = totalLength - usedIndent - self.rightIndent
        done = 0
        line = []
        cursor = 0
        lineIsFull = 0
        currentLength = 0
        maxcursor = len(program)
        needspace = 0
        first = 1
        terminated = None
        fontName = self.fontName
        fontSize = self.fontSize
        spacewidth = stringWidth(" ", fontName, fontSize) #self.sizeOfWord(" ")
        justStrings = 1
        while not done and cursor<maxcursor:
            opcode = program[cursor]
            #if debug: print "opcode", cursor, opcode
            if isinstance(opcode,str) or hasattr(opcode,'width'):
                lastneedspace = needspace
                needspace = 0
                if hasattr(opcode,'width'):
                    justStrings = 0
                    width = opcode.width(self)
                    needspace = 0
                else:
                    saveopcode = opcode
                    opcode = opcode.strip()
                    if opcode:
                        width = stringWidth(opcode, fontName, fontSize)
                    else:
                        width = 0
                    if saveopcode and (width or currentLength):
                        # ignore white space at margin
                        needspace = (saveopcode[-1]==" ")
                    else:
                        needspace = 0
                fullwidth = width
                if lastneedspace:
                    #spacewidth = stringWidth(" ", fontName, fontSize) #self.sizeOfWord(" ")
                    fullwidth = width + spacewidth
                newlength = currentLength+fullwidth
                if newlength>maxLength and not first: # always do at least one thing
                    # this word won't fit
                    #if debug:
                    #    print "WORD", opcode, "wont fit, width", width, "fullwidth", fullwidth
                    #    print "   currentLength", currentLength, "newlength", newlength, "maxLength", maxLength
                    done = 1
                    lineIsFull = 1
                else:
                    # fit the word: add a space then the word
                    if lastneedspace:
                        line.append( spacewidth ) # expandable space: positive
                    if opcode:
                        line.append( opcode )
                    if abs(width)>TOOSMALLSPACE:
                        line.append( -width ) # non expanding space: negative
                        currentLength = newlength
                    #print line
                    #stop
                first = 0
            elif isinstance(opcode,float):
                justStrings = 0
                aopcode = abs(opcode) # negative means non expanding
                if aopcode>TOOSMALLSPACE:
                    nextLength = currentLength+aopcode
                    if nextLength>maxLength and not first: # always do at least one thing
                        #if debug: print "EXPLICIT spacer won't fit", maxLength, nextLength, opcode
                        done = 1
                    else:
                        if aopcode>TOOSMALLSPACE:
                            currentLength = nextLength
                            line.append(opcode)
                    first = 0
            elif isinstance(opcode,tuple):
                justStrings = 0
                indicator = opcode[0]
                #line.append(opcode)
                if indicator=="nextLine":
                    # advance to nextLine
                    #(i, endallmarks) = opcode
                    line.append(opcode)
                    cursor = cursor+1 # consume this element
                    terminated = done = 1
                    #if debug:
                    #    print "nextLine encountered"
                elif indicator=="color":
                    # change fill color
                    oldcolor = self.fontColor
                    (i, colorname) = opcode
                    #print "opcode", opcode
                    if isinstance(colorname,str):
                        color = self.fontColor = getattr(colors, colorname)
                    else:
                        color = self.fontColor = colorname # assume its something sensible :)
                    line.append(opcode)
                elif indicator=="face":
                    # change font face
                    (i, fontname) = opcode
                    fontName = self.fontName = fontname
                    spacewidth = stringWidth(" ", fontName, fontSize) #self.sizeOfWord(" ")
                    line.append(opcode)
                elif indicator=="size":
                    # change font size
                    (i, fontsize) = opcode
                    size = abs(float(fontsize))
                    if isinstance(fontsize,str):
                        if fontsize[:1]=="+":
                            fontSize = self.fontSize = self.fontSize + size
                        elif fontsize[:1]=="-":
                            fontSize = self.fontSize = self.fontSize - size
                        else:
                            fontSize = self.fontSize = size
                    else:
                        fontSize = self.fontSize = size
                    spacewidth = stringWidth(" ", fontName, fontSize) #self.sizeOfWord(" ")
                    line.append(opcode)
                elif indicator=="leading":
                    # change font leading
                    (i, leading) = opcode
                    self.leading = leading
                    line.append(opcode)
                elif indicator=="indent":
                    # increase the indent
                    (i, increment) = opcode
                    indent = self.indent = self.indent + increment
                    if first:
                        usedIndent = max(indent, usedIndent)
                        maxLength = totalLength - usedIndent - self.rightIndent
                    line.append(opcode)
                elif indicator=="push":
                    self.pushTextState()
                    line.append(opcode)
                elif indicator=="pop":
                    try:
                        self.popTextState()
                    except:
##                        print "stack fault near", cursor
##                        for i in program[max(0, cursor-10):cursor+10]:
##                            if i==cursor:
##                                print "***>>>",
##                            print i
                        raise
                    fontName = self.fontName
                    fontSize = self.fontSize
                    spacewidth = stringWidth(" ", fontName, fontSize) #self.sizeOfWord(" ")
                    line.append(opcode)
                elif indicator=="bullet":
                    (i, bullet, indent, font, size) = opcode
                    # adjust for base indent (only at format time -- only execute once)
                    indent = indent + self.baseindent
                    opcode = (i, bullet, indent, font, size)
                    if not first:
                        raise ValueError("bullet not at beginning of line")
                    bulletwidth = float(stringWidth(bullet, font, size))
                    spacewidth = float(stringWidth(" ", font, size))
                    bulletmin = indent+spacewidth+bulletwidth
                    # decrease the line size to allow bullet
                    usedIndent = max(bulletmin, usedIndent)
                    if first:
                        maxLength = totalLength - usedIndent - self.rightIndent
                    line.append(opcode)
                elif indicator=="rightIndent":
                    # increase the right indent
                    (i, increment) = opcode
                    self.rightIndent = self.rightIndent+increment
                    if first:
                        maxLength = totalLength - usedIndent - self.rightIndent
                    line.append(opcode)
                elif indicator=="rise":
                    (i, rise) = opcode
                    newrise = self.rise = self.rise+rise
                    line.append(opcode)
                elif indicator=="align":
                    (i, alignment) = opcode
                    #if debug:
                    #    print "SETTING ALIGNMENT", alignment
                    self.alignment = alignment
                    line.append(opcode)
                elif indicator=="lineOperation":
                    (i, handler) = opcode
                    line.append(opcode)
                    self.lineOpHandlers = self.lineOpHandlers + [handler] # fresh copy
                elif indicator=="endLineOperation":
                    (i, handler) = opcode
                    h = self.lineOpHandlers[:] # fresh copy
                    h.remove(handler)
                    self.lineOpHandlers = h
                    line.append(opcode)

                else:
                    raise ValueError("at format time don't understand indicator "+repr(indicator))
            else:
                raise ValueError("op must be string, float, instance, or tuple "+repr(opcode))
            if not done:
                cursor = cursor+1
                #first = 0
##            if debug:
##                if done:
##                    print "DONE FLAG IS SET"
##                if cursor>=maxcursor:
##                    print "AT END OF PROGRAM"
        if not terminated:
            line.append( ("nextLine", 0) )
        #print "fitline", line
        return (lineIsFull, line, cursor, currentLength, usedIndent, maxLength, justStrings)

    def centerAlign(self, line, lineLength, maxLength):
        diff = maxLength-lineLength
        shift = diff/2.0
        if shift>TOOSMALLSPACE:
            return self.insertShift(line, shift)
        return line

    def rightAlign(self, line, lineLength, maxLength):
        shift = maxLength-lineLength
        #die
        if shift>TOOSMALLSPACE:
            return self.insertShift(line, shift)
        return line

    def insertShift(self, line, shift):
        # insert shift just before first visible element in line
        result = []
        first = 1
        for e in line:
            if first and (isinstance(e,str) or hasattr(e,'width')):
                result.append(shift)
                first = 0
            result.append(e)
        return result

    def justifyAlign(self, line, lineLength, maxLength):
        diff = maxLength-lineLength
        # count EXPANDABLE SPACES AFTER THE FIRST VISIBLE
        spacecount = 0
        visible = 0
        for e in line:
            if isinstance(e,float) and e>TOOSMALLSPACE and visible:
                spacecount = spacecount+1
            elif first and (isinstance(e,str) or hasattr(e,'width')):
                visible = 1
        #if debug: print "diff is", diff, "wordcount", wordcount #; die
        if spacecount<1:
            return line
        shift = diff/float(spacecount)
        if shift<=TOOSMALLSPACE:
            #if debug: print "shift too small", shift
            return line
        first = 1
        visible = 0
        result = []
        cursor = 0
        nline = len(line)
        while cursor<nline:
            e = line[cursor]
            result.append(e)
            if first and (isinstance(e,str) or hasattr(e,'width')):
                visible = 1
            elif isinstance(e,float) and e>TOOSMALLSPACE and visible:
                expanded = e+shift
                result[-1] = expanded
            cursor = cursor+1
        return result

##                if not first:
##                    #if debug: print "shifting", shift, e
##                    #result.append(shift)
##                    # add the shift in result before any start markers before e
##                    insertplace = len(result)-1
##                    done = 0
##                    myshift = shift
##                    while insertplace>0 and not done:
##                        beforeplace = insertplace-1
##                        beforething = result[beforeplace]
##                        if isinstance(beforething,tuple):
##                            indicator = beforething[0]
##                            if indicator=="endLineOperation":
##                                done = 1
##                            elif debug:
##                                print "adding shift before", beforething
##                       elif isinstance(beforething,float):
##                            myshift = myshift + beforething
##                            del result[beforeplace]
##                        else:
##                            done = 1
##                        if not done:
##                            insertplace = beforeplace
##                    result.insert(insertplace, myshift)
##                first = 0
##            cursor = cursor+1
##        return result

    def shrinkWrap(self, line):
        # for non justified text, collapse adjacent text/shift's into single operations
        result = []
        index = 0
        maxindex = len(line)
        while index<maxindex:
            e = line[index]
            if isinstance(e,str) and index<maxindex-1:
                # collect strings and floats
                thestrings = [e]
                thefloats = 0.0
                index = index+1
                nexte = line[index]
                while index<maxindex and isinstance(nexte,(float,str)):
                    # switch to expandable space if appropriate
                    if isinstance(nexte,float):
                        if thefloats<0 and nexte>0:
                            thefloats = -thefloats
                        if nexte<0 and thefloats>0:
                            nexte = -nexte
                        thefloats = thefloats + nexte
                    elif isinstance(nexte,str):
                        thestrings.append(nexte)
                    index = index+1
                    if index<maxindex:
                        nexte = line[index]
                # wrap up the result
                s = ' '.join(thestrings)
                result.append(s)
                result.append(float(thefloats))
                # back up for unhandled element
                index = index-1
            else:
                result.append(e)
            index = index+1

        return result

    def cleanProgram(self, line):
        "collapse adjacent spacings"
        #return line # for debugging
        result = []
        last = 0
        for e in line:
            if isinstance(e,float):
                # switch to expandable space if appropriate
                if last<0 and e>0:
                    last = -last
                if e<0 and last>0:
                    e = -e
                last = float(last)+e
            else:
                if abs(last)>TOOSMALLSPACE:
                    result.append(last)
                result.append(e)
                last = 0
        if last:
            result.append(last)
        # now go backwards and delete all floats occurring after all visible elements
##        count = len(result)-1
##        done = 0
##        while count>0 and not done:
##            e = result[count]
##            if hasattr(e,'width') or isinstance(e,str):
##                done = 1
##            elif isinstance(e,float):
##                del result[count]
##            count = count-1
        # move end operations left and start operations left up to visibles
        change = 1
        rline = list(range(len(result)-1))
        while change:
            #print line
            change = 0
            for index in rline:
                nextindex = index+1
                this = result[index]
                next = result[nextindex]
                doswap = 0
                # don't swap visibles
                if isinstance(this,str) or \
                   isinstance(next,str) or \
                   hasattr(this,'width') or hasattr(next,'width'):
                    doswap = 0
                # only swap two tuples if the second one is an end operation and the first is something else
                elif isinstance(this,tuple):
                    thisindicator = this[0]
                    if isinstance(next,tuple):
                        nextindicator = next[0]
                        doswap = 0
                        if (nextindicator=="endLineOperation" and thisindicator!="endLineOperation"
                            and thisindicator!="lineOperation"):
                            doswap = 1 # swap nonend!=end
                    elif isinstance(next,float):
                        if thisindicator=="lineOperation":
                            doswap = 1 # begin != space
                if doswap:
                    #print "swap", line[index],line[nextindex]
                    result[index] = next
                    result[nextindex] = this
                    change = 1
        return result

    def runOpCodes(self, program, canvas, textobject):
        "render the line(s)"

        escape = canvas._escape
        code = textobject._code
        startstate = self.__dict__.copy()
        font = None
        size = None
        # be sure to set them before using them (done lazily below)
        #textobject.setFont(self.fontName, self.fontSize)
        textobject.setFillColor(self.fontColor)
        xstart = self.x
        thislineindent = self.indent
        thislinerightIndent = self.rightIndent
        indented = 0
        for opcode in program:
            if isinstance(opcode,str)  or hasattr(opcode,'width'):
                if not indented:
                    if abs(thislineindent)>TOOSMALLSPACE:
                        #if debug: print "INDENTING", thislineindent
                        #textobject.moveCursor(thislineindent, 0)
                        code.append('%s Td' % fp_str(thislineindent, 0))
                        self.x = self.x + thislineindent
                    for handler in self.lineOpHandlers:
                        #handler.end_at(x, y, self, canvas, textobject) # finish, eg, underlining this line
                        handler.start_at(self.x, self.y, self, canvas, textobject) # start underlining the next
                indented = 1
                # lazily set font (don't do it again if not needed)
                if font!=self.fontName or size!=self.fontSize:
                    font = self.fontName
                    size = self.fontSize
                    textobject.setFont(font, size)
                if isinstance(opcode,str):
                    textobject.textOut(opcode)
                else:
                    # drawable thing
                    opcode.execute(self, textobject, canvas)
            elif isinstance(opcode,float):
                # use abs value (ignore expandable marking)
                opcode = abs(opcode)
                if opcode>TOOSMALLSPACE:
                    #textobject.moveCursor(opcode, 0)
                    code.append('%s Td' % fp_str(opcode, 0))
                    self.x = self.x + opcode
            elif isinstance(opcode,tuple):
                indicator = opcode[0]
                if indicator=="nextLine":
                    # advance to nextLine
                    (i, endallmarks) = opcode
                    x = self.x
                    y = self.y
                    newy = self.y = self.y-self.leading
                    newx = self.x = xstart
                    thislineindent = self.indent
                    thislinerightIndent = self.rightIndent
                    indented = 0
                    for handler in self.lineOpHandlers:
                        handler.end_at(x, y, self, canvas, textobject) # finish, eg, underlining this line
                        #handler.start_at(newx, newy, self, canvas, textobject)) # start underlining the next
                    textobject.setTextOrigin(newx, newy)
                elif indicator=="color":
                    # change fill color
                    oldcolor = self.fontColor
                    (i, colorname) = opcode
                    #print "opcode", opcode
                    if isinstance(colorname,str):
                        color = self.fontColor = getattr(colors, colorname)
                    else:
                        color = self.fontColor = colorname # assume its something sensible :)
                    #if debug:
                    #    print color.red, color.green, color.blue
                    #    print dir(color)
                    #print "color is", color
                    #from reportlab.lib.colors import green
                    #if color is green: print "color is green"
                    if color!=oldcolor:
                        textobject.setFillColor(color)
                elif indicator=="face":
                    # change font face
                    (i, fontname) = opcode
                    self.fontName = fontname
                    #textobject.setFont(self.fontName, self.fontSize)
                elif indicator=="size":
                    # change font size
                    (i, fontsize) = opcode
                    size = abs(float(fontsize))
                    if isinstance(fontsize,str):
                        if fontsize[:1]=="+":
                            fontSize = self.fontSize = self.fontSize + size
                        elif fontsize[:1]=="-":
                            fontSize = self.fontSize = self.fontSize - size
                        else:
                            fontSize = self.fontSize = size
                    else:
                        fontSize = self.fontSize = size
                    #(i, fontsize) = opcode
                    self.fontSize = fontSize
                    textobject.setFont(self.fontName, self.fontSize)
                elif indicator=="leading":
                    # change font leading
                    (i, leading) = opcode
                    self.leading = leading
                elif indicator=="indent":
                    # increase the indent
                    (i, increment) = opcode
                    ind